import React, { useState, useEffect, useContext } from "react";
import axios from "../utils/axiosConfig";
import { ToastContainer, toast } from "react-toastify";
import { AuthContext } from "../context/AuthContext";
import AssetModal from "../components/AssetModal";
import AssetTable from "../components/AssetTable";
import { motion } from "framer-motion";
import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import { socket } from "../services/socket";
import LoadingSpinner from "../components/common/LoadingSpinner";
import { useLocation } from "react-router-dom";
import { Button, Card, Badge, Input, PermissionGuard } from "../components/UI";
import { assetSchema } from "../utils/assetSchema";

/**
 * Enterprise Asset Matrix
 * Features: High-accuracy telemetry, Role-based metadata editing, Forensic PDF reporting.
 */

export default function Assets() {
  const { user } = useContext(AuthContext);
  const location = useLocation();
  const [assets, setAssets] = useState([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingAsset, setEditingAsset] = useState(null);

  // Search Synchronization
  const [search, setSearch] = useState(new URLSearchParams(window.location.search).get("search") || "");
  const [statusFilter, setStatusFilter] = useState("All");
  const [typeFilter, setTypeFilter] = useState("All");
  const [sortBy, setSortBy] = useState("name");
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const querySearch = new URLSearchParams(location.search).get("search");
    if (querySearch !== null && querySearch !== search) setSearch(querySearch);
  }, [location.search]);

  useEffect(() => {
    fetchAssets();
    if (window.location.search.includes("add=true")) {
      setEditingAsset(null);
      setIsModalOpen(true);
      window.history.replaceState({}, document.title, window.location.pathname);
    }

    // REAL-TIME CLUSTER SYNC (Â§Category 4 & 9)
    socket.on("assetCreated", (newAsset) => {
      setAssets(prev => [newAsset, ...prev]);
      toast.info(`New Node Detected: ${newAsset.name}`);
    });

    socket.on("assetUpdated", (updated) => {
      setAssets(prev => prev.map(a => a._id === updated._id ? updated : a));
    });

    socket.on("assetDeleted", (id) => {
      setAssets(prev => prev.filter(a => a._id !== id));
      toast.warn("Asset Decommissioned by Remote Admin");
    });

    return () => {
      socket.off("assetCreated");
      socket.off("assetUpdated");
      socket.off("assetDeleted");
    };
  }, [search, statusFilter, typeFilter, sortBy]);


  const fetchAssets = async () => {
    try {
      setLoading(true);
      const params = new URLSearchParams();
      if (search) params.append("search", search);
      if (statusFilter !== "All") params.append("status", statusFilter);
      if (typeFilter !== "All") params.append("type", typeFilter);
      if (sortBy) params.append("sort", sortBy);

      const res = await axios.get(`/assets?${params.toString()}`);
      setAssets(res.data.assets || res.data || []);
    } catch (error) {
      toast.error("Telemetry link failed: Asset Registry synchronization error.");
    } finally {
      setLoading(false);
    }
  };

  const handleCreate = async (formData) => {
    try {
      if (editingAsset) {
        await axios.put(`/assets/${editingAsset._id}`, formData);
        toast.success("Asset Metadata Updated");
      } else {
        await axios.post("/assets", formData);
        toast.success("New Asset Node Initialized");
      }
      setIsModalOpen(false);
      setEditingAsset(null);
      fetchAssets();
    } catch (error) {
      toast.error(error.response?.data?.message || "Registry Update Rejected");
    }
  };

  const handleDelete = async (id) => {
    try {
      await axios.delete(`/assets/${id}`);
      toast.success("Decommission Protocol Executed Successfully");
      fetchAssets();
    } catch (error) {
      toast.error("Decommission Rejected: System/Role Violation");
    }
  };

  const handleExportPDF = async () => {
    if (assets.length === 0) {
      toast.error("No assets available for export.");
      return;
    }

    try {
      const doc = new jsPDF('landscape'); // Landscape to fit extra columns cleanly
      doc.setFontSize(22);
      doc.text("Asset Inventory Report", 14, 20);
      doc.setFontSize(10);
      doc.text(`Generated By: ${user?.name || "System"} (${user?.role || "User"})`, 14, 28);
      doc.text(`Generated On: ${new Date().toUTCString()}`, 14, 34);

      // Validate Data Integrity before PDF Generation
      const validationResult = assetSchema.validateExportData(assets);
      if (!validationResult.valid) {
        toast.error(`Data Integrity Failure: ${validationResult.error}`);
        return;
      }

      // Generate Table Headers Dynamically from Schema
      const schemaKeys = Object.keys(assetSchema.exportableFields);
      const tableColumn = schemaKeys.map((key) => assetSchema.exportableFields[key]);

      // Generate Table Rows Dynamically
      const tableRows = assets.map((asset) => {
        return schemaKeys.map((key) => {
          return assetSchema.formatters[key] ? assetSchema.formatters[key](asset) : "N/A";
        });
      });

      autoTable(doc, {
        head: [tableColumn],
        body: tableRows,
        startY: 42,
        theme: 'grid',
        styles: { fontSize: 9, cellPadding: 3, overflow: 'linebreak' },
        headStyles: { fillColor: [15, 23, 42], textColor: [255, 255, 255], fontStyle: 'bold' }
      });

      doc.save(`Asset_Inventory_Report_${new Date().toISOString().split("T")[0]}.pdf`);

      try {
        await axios.post('/audit', {
          action: 'REPORT_EXPORT',
          details: `Exported Asset Inventory Report PDF containing ${assets.length} assets.`
        });
      } catch (e) {
        // Soft fail audit log if endpoint isn't wired for general logs
      }

      toast.success("Asset Inventory Report Exported Successfully");
    } catch (error) {
      console.error(error);
      toast.error("PDF export failed. Please retry.");
    }
  };

  const openEditModal = (asset) => {
    setEditingAsset(asset);
    setIsModalOpen(true);
  };

  // Derivative Statistics Calculation (Requirement G: Accurate)
  const stats = {
    total: assets.length,
    available: assets.filter(a => a.status === "available").length,
    assigned: assets.filter(a => a.status === "assigned").length,
    maintenance: assets.filter(a => a.status === "maintenance").length,
    retired: assets.filter(a => a.status === "retired").length,
  };

  const assetTypes = [...new Set(assets.map(a => a.type))].filter(Boolean);

  return (
    <div className="fade-in pb-12">
      <ToastContainer position="top-right" autoClose={3000} theme="dark" />

      {/* Primary Context Header */}
      <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-10 gap-4">
        <div>
          <h1 className="text-3xl font-extrabold text-white tracking-tighter uppercase">Asset Inventory</h1>
          <p className="text-slate-500 font-medium mt-1 text-xs tracking-widest uppercase">
            Cluster Management & Deployment Operations
          </p>
        </div>
        <div className="flex flex-wrap gap-3">
          <Button variant="secondary" onClick={handleExportPDF} disabled={assets.length === 0}>
            Export Inventory (PDF)
          </Button>
          <PermissionGuard roles={["Super Admin", "Admin"]} userRole={user?.role}>
            <Button variant="primary" onClick={() => { setEditingAsset(null); setIsModalOpen(true); }}>
              Provision New Node
            </Button>
          </PermissionGuard>
        </div>
      </div>

      {/* Snapshot Ledger (Requirement G: Accurate Counters) */}
      <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-10">
        {[
          { label: "Total Assets", value: stats.total, color: "blue" },
          { label: "Available", value: stats.available, color: "green" },
          { label: "Assigned", value: stats.assigned, color: "sky" },
          { label: "In Service", value: stats.maintenance, color: "amber" },
          { label: "Archived", value: stats.retired, color: "red" },
        ].map((stat) => (
          <Card key={stat.label} className={`border-l-2 border-l-${stat.color}-500/30 p-4 bg-slate-900/40`}>
            <div className="text-[10px] uppercase font-black text-slate-500 tracking-wider mb-1">{stat.label}</div>
            <div className={`text-2xl font-black text-${stat.color}-500 tabular-nums`}>{stat.value}</div>
          </Card>
        ))}
      </div>

      {/* Filter Intelligence */}
      <Card className="mb-8 p-3 bg-slate-900/60">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <Input
            placeholder="Search by Serial Number, Asset Name, or Owner..."
            className="mb-0"
            value={search}
            onChange={(e) => setSearch(e.target.value)}
          />
          <select
            className="input bg-slate-950/40 border-white/5"
            value={statusFilter}
            onChange={(e) => setStatusFilter(e.target.value)}
          >
            <option value="All">Filter by Operational Status</option>
            <option value="available">Available / Inventory</option>
            <option value="assigned">Live / Assigned</option>
            <option value="maintenance">Maintenance</option>
            <option value="retired">Archived</option>
          </select>
          <select
            className="input bg-slate-950/40 border-white/5"
            value={typeFilter}
            onChange={(e) => setTypeFilter(e.target.value)}
          >
            <option value="All">Filter by Cluster</option>
            {assetTypes.map(t => <option key={t} value={t}>{t}</option>)}
          </select>
          <select
            className="input bg-slate-950/40 border-white/5"
            value={sortBy}
            onChange={(e) => setSortBy(e.target.value)}
          >
            <option value="name">Sort by Asset Name (A-Z)</option>
            <option value="createdAt">Sort: Deployment Date</option>
            <option value="status">Sort: Operational Status</option>
            <option value="usefulLifeYears">Sort: Lifecycle Phase</option>
          </select>
        </div>
      </Card>

      {/* Data Visualization Grid (Item D: Responsive Scroll) */}
      <div className="w-full">
        {loading ? (
          <div className="py-24"><LoadingSpinner message="Scanning Registry Cluster..." /></div>
        ) : (
          <AssetTable
            assets={assets}
            onEdit={openEditModal}
            onDelete={handleDelete}
            user={user}
          />
        )}
      </div>

      {/* Global Metadata Editor */}
      <AssetModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        onSubmit={handleCreate}
        initialData={editingAsset}
      />
    </div>
  );
}
